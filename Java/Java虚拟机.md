# 第一部分 走近Java

## 第1章 走进Java







# 第二部分 自动内存管理

## 第2章 Java内存区域与内存溢出异常

### 1 运行时数据区域

**程序计数器：**

- 当前线程执行的字节码的行号指示器
- 线程私有

**Java虚拟机栈：**

- 线程私有
- 每个方法被执行时都会创建一个栈帧
- 虚拟机栈-局部变量表-局部变量槽（Slot）
  - 1个变量槽32bit或64bit，甚至更多
  - long、double类型占用2个变量槽，其他数据类型占用1个
- HotSpot不支持动态扩展栈容量
- HotSpot将本地方法栈和虚拟机栈合二为一
- 栈深度溢出：StackOverFlowError
- 栈扩展失败（或申请栈空间失败）：OutOfMemoryError

**Java堆：**

- 唯一目的：存放对象实例
- 物理空间可不连续，逻辑上连续
- 可选固定大小或者可扩展
- 无法再实例分配或扩展：OutOfMemoryError

**方法区：**

- 永久代*（JVM用管理堆的办法管理方法区）*--->元空间*（JDK8及以后）*
- 不需要连续的内存
- 可选固定大小或者可扩展
- 可选不实现垃圾收集
- 运行时常量池：
  - 加载Class文件中的常量池表（包含各种字面量与符号引用）
  - 动态性：运行期间也可以将新的常量放入池中
- 无法满足新的内存分配需求：OutOfMemoryError

**直接内存：**

- 不是虚拟机运行时数据区的一部分
- JDK1.4中引入，在一些场景中显著提高性能



### 2 HotSpot虚拟机对象

**虚拟机创建对象的步骤：**

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用
2. 为新生对象分配内存，分配方式：
   - 指针碰撞（Bump The Pointer）
   - 空闲列表（Free List）
3. 将分配到的内存空间初始化为零值
4. 对对象进行必要的设置

对象在堆内存中的**存储布局**可以分为3个部分：

1. 对象头
   - 存储自身运行时数据（如HashCode等）
   - 存储类型指针
2. 实例数据
   - 默认分配顺序
   - 相同宽度字段分配到一起
   - 满足上一个条件的情况下，父类中定义的变量出现在子类之前
3. 对齐填充
   - 对象起始地址必须为8字节的整数倍

**对象的访问方式：**

- 使用**句柄**访问（句柄池，实例池）

![](Java虚拟机.assets/1.png)

- 使用**直接指针**访问

![](Java虚拟机.assets/2.png)





## 第3章 垃圾收集器与内存分配策略

### 1 垃圾收集

垃圾收集（Garbage Collection，GC）

- **程序计数器**、**虚拟机栈**、**本地方法栈**的内存在<u>方法或线程结束时</u>就跟着回收了
- **Java堆**和**方法区**的内存的分配和回收是<u>动态</u>的

**对象回收判断方法：**

1. **引用计数算法**
   - 对象被引用一次，计数器值+1
   - 引用失效，计数器值-1
   - 计数器值=0将被GC回收
2. **可达性分析算法**（Java采用）
   - GC Roots：起始节点集
   - GC Roots到某个对象不可达，则此对象可回收
   - 回收对象的两次标记过程：
     1. 是否有与GC Roots相连接的<u>引用链</u>
     2. 对象是否覆盖`finalize()`方法或`finalize()`方法已被调用过

引用类型强度：**强引用**>**软引用**>**弱引用**>**虚引用**

**回收方法区：**

- 判定回收常量的条件：当前系统没有任何一个字符串对象的值是该常量
- 判定回收类型的条件：
  - 该类所有的<u>实例</u>都已经被回收
  - 加载该类的<u>类加载器</u>已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用*（反射）*



### 2 垃圾收集算法

**分代收集理论**：

- 建立在以下假说之上：
  1. 弱分代假说：绝大多数对象都是朝生夕灭的
  2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
  3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数
- 在主流Java虚拟机里体现为Java堆被划分成：
  1. **新生代（Young Generation）：**大量将要被回收的对象
  2. **老年代（Old Generation）：**由未被回收的新生代对象逐步晋升，转而放入老年代存放

---

**标记-清除算法：**最基础的收集算法

**标记-复制算法：**半区复制算法--->Appel式回收算法

Appel式回收：

- 新生代内存分为Eden(80%)+2*Survivor(10%)
- 分配担保（Handle Promotion）：Survivor空间不足就需要其他内存区域

**标记-整理算法：**让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存

在HotSpot中，Parallel Old收集器是基于标记-整理算法的，CMS收集器是基于标记-清除算法的



### 3 HotSpot的算法细节实现

所有收集器在**根节点枚举**这一步骤时都是必须暂停用户线程的*（所谓Stop The World）*

HotSpot使用**OopMap**的数据结构直接准确得到哪些地方存放着对象引用
--->为避免每条指令都生成OopMap，设置一定数量的**安全点（Safepoint）**，代码指令流到达安全点后才能够暂停程序并开始垃圾收集
--->抢先式中断*（全中断并检查是否在安全点上）*和主动式中断*（轮询标志位）*

**安全区域：**引用关系不发生变化的代码片段

**记忆集：**一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构

**卡表：**实现记忆集的一种方式，定义了记忆集的记录精度、与堆内存的映射关系等

HotSpot通过**写屏障**技术维护卡表状态

- 三色标记：黑色（存活）、灰色（正在扫描）、白色（不可达）
- 并发出现”对象消失“问题的条件（同时满足）：
  - 赋值器插入了一条或多条从黑色对象到白色对象的新引用
  - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

增量更新：CMS采用

原始快照：G1采用



### 4 垃圾收集器

衡量垃圾收集器的三项最重要的指标：

- 内存占用（Footprint）
- 吞吐量（Throughput）
- 延迟（Latency）

1. **Serial收集器**
   - 单线程工作（进行垃圾收集时必须暂停其他所有工作线程）
   - 基于标记-复制算法的新生代收集器
   - 简单而高效
   - 多用在客户端
2. **ParNew收集器**
   - 实质上是Serial收集器的多线程并行版本
   - 通常与CMS收集器配合工作
   - 多用在服务端
3. **Parallel Scavenge收集器**
   - 并行多线程
   - 基于标记-复制算法的新生代收集器
   - 吞吐量优先收集器
   - 垃圾收集的自适应调节策略
4. **Serial Old收集器**
   - 实质上是Serial收集器的老年代版本
   - 基于标记-整理算法的实现
5. **Parallel Old收集器**
   - 实质上是Parallel Scavenge收集器的老年版本
   - 基于标记-整理算法实现
6. **CMS收集器**
   - 基于标记-清除算法实现
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 重新标记
     4. 并发清除
   - 缺点：
     - 对处理器资源非常敏感（并发）
     - 无法处理浮动垃圾（并发清除阶段产生的新垃圾）
     - 收集结束时会产生大量空间碎片（标记-清除算法的缺陷）
7. **Garbage First收集器**
   - 设计思路：面向局部收集
   - 内存布局形式：基于Region
     - 把Java堆划分为多个<u>大小相等</u>的独立区域
     - 不同的Region可以扮演不同角色
     - 收集器对不同的角色的Region采用不同的策略
     - Humongous区域用来存储大对象
     - Region是单次回收的最小单元
     - 可预测的<u>停顿时间模型</u>--->维护一个<u>优先级列表</u>（不同Region的回收价值大小）
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 最终标记
     4. 筛选回收
8. **Shenandoah收集器**
   - 摒弃了记忆集，采用<u>连接矩阵</u>的全局数据结构来记录跨Region的引用关系
   - 工作过程：
     1. 初始标记
     2. **并发标记**
     3. 最终标记
     4. 并发清理
     5. **并发回收**
     6. 初始引用更新
     7. **并发引用更新**
     8. 最终引用更新
     9. 并发清理
   - 通过读屏障和转发指针*Brooks Pointers*来解决并发回收阶段的困难
9. **ZGC收集器**
   - 低延迟，并发，标记-整理算法
   - 基于Region内存布局
   - 读屏障
   - 染色指针
   - 内存多重映射
   - 工作过程：
     1. 并发标记
     2. 并发预备重分配
     3. 并发重分配
     4. 并发重映射

