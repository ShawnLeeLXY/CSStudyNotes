# 第一部分 自动内存管理

## 第1章 Java内存区域与内存溢出异常

### 1 运行时数据区域

**程序计数器：**

- 当前线程执行的字节码的行号指示器
- 线程私有

**Java虚拟机栈：**

- 线程私有
- 每个方法被执行时都会创建一个栈帧
- 虚拟机栈-局部变量表-局部变量槽（Slot）
  - 1个变量槽32bit或64bit，甚至更多
  - long、double类型占用2个变量槽，其他数据类型占用1个
- HotSpot不支持动态扩展栈容量
- HotSpot将本地方法栈和虚拟机栈合二为一
- 栈深度溢出：StackOverFlowError
- 栈扩展失败（或申请栈空间失败）：OutOfMemoryError

**Java堆：**

- 唯一目的：存放对象实例
- 物理空间可不连续，逻辑上连续
- 可选固定大小或者可扩展
- 无法再实例分配或扩展：OutOfMemoryError

**方法区：**

- 永久代*（JVM用管理堆的办法管理方法区）*--->元空间*（JDK8及以后）*
- 不需要连续的内存
- 可选固定大小或者可扩展
- 可选不实现垃圾收集
- 运行时常量池：
  - 加载Class文件中的常量池表（包含各种字面量与符号引用）
  - 动态性：运行期间也可以将新的常量放入池中
- 无法满足新的内存分配需求：OutOfMemoryError

**直接内存：**

- 不是虚拟机运行时数据区的一部分
- JDK1.4中引入，在一些场景中显著提高性能





### 2 HotSpot虚拟机对象

**虚拟机创建对象的步骤：**

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用
2. 为新生对象分配内存，分配方式：
   - 指针碰撞（Bump The Pointer）
   - 空闲列表（Free List）
3. 将分配到的内存空间初始化为零值
4. 对对象进行必要的设置

对象在堆内存中的**存储布局**可以分为3个部分：

1. 对象头
   - 存储自身运行时数据（如HashCode、对象年龄计数器等）
   - 存储类型指针
2. 实例数据
   - 默认分配顺序
   - 相同宽度字段分配到一起
   - 满足上一个条件的情况下，父类中定义的变量出现在子类之前
3. 对齐填充
   - 对象起始地址必须为8字节的整数倍

**对象的访问方式：**

- 使用**句柄**访问（句柄池，实例池）

![](Java虚拟机.assets/1.png)

- 使用**直接指针**访问

![](Java虚拟机.assets/2.png)







## 第2章 垃圾收集器与内存分配策略

### 1 垃圾收集

垃圾收集（Garbage Collection，GC）

- **程序计数器**、**虚拟机栈**、**本地方法栈**的内存在<u>方法或线程结束时</u>就跟着回收了
- **Java堆**和**方法区**的内存的分配和回收是<u>动态</u>的

**对象回收判断方法：**

1. **引用计数算法**
   - 对象被引用一次，计数器值+1
   - 引用失效，计数器值-1
   - 计数器值=0将被GC回收
2. **可达性分析算法**（Java采用）
   - GC Roots：起始节点集
   - GC Roots到某个对象不可达，则此对象可回收
   - 回收对象的两次标记过程：
     1. 是否有与GC Roots相连接的<u>引用链</u>
     2. 对象是否覆盖`finalize()`方法或`finalize()`方法已被调用过

引用类型强度：**强引用**>**软引用**>**弱引用**>**虚引用**

**回收方法区：**

- 判定回收常量的条件：当前系统没有任何一个字符串对象的值是该常量
- 判定回收类型的条件：
  - 该类所有的<u>实例</u>都已经被回收
  - 加载该类的<u>类加载器</u>已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用*（反射）*





### 2 垃圾收集算法

**分代收集理论**：

- 建立在以下假说之上：
  1. 弱分代假说：绝大多数对象都是朝生夕灭的
  2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
  3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数
- 在主流Java虚拟机里体现为Java堆被划分成：
  1. **新生代（Young Generation）：**大量将要被回收的对象
  2. **老年代（Old Generation）：**由未被回收的新生代对象逐步晋升，转而放入老年代存放

---

- Partial GC:
  - Minor GC: 收集新生代
  - Major GC: 收集老年代（CMS）
  - Mixed GC: 整个新生代+部分老年代（G1）
- Full GC: 整个Java堆+方法区

---

**标记-清除算法：**最基础的收集算法

**标记-复制算法：**半区复制算法--->Appel式回收算法

Appel式回收：

- 新生代内存分为Eden(80%)+2*Survivor(10%)
- 分配担保（Handle Promotion）：Survivor空间不足就需要其他内存区域

**标记-整理算法：**让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存

在HotSpot中，Parallel Old收集器是基于标记-整理算法的，CMS收集器是基于标记-清除算法的





### 3 HotSpot的算法细节实现

所有收集器在**根节点枚举**这一步骤时都是必须暂停用户线程的*（所谓Stop The World）*

HotSpot使用**OopMap**的数据结构直接准确得到哪些地方存放着对象引用
--->为避免每条指令都生成OopMap，设置一定数量的**安全点（Safepoint）**，代码指令流到达安全点后才能够暂停程序并开始垃圾收集
--->抢先式中断*（全中断并检查是否在安全点上）*和主动式中断*（轮询标志位）*

**安全区域：**引用关系不发生变化的代码片段

**记忆集：**一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构

**卡表：**实现记忆集的一种方式，定义了记忆集的记录精度、与堆内存的映射关系等

HotSpot通过**写屏障**技术维护卡表状态

- 三色标记：黑色（存活）、灰色（正在扫描）、白色（不可达）
- 并发出现”对象消失“问题的条件（同时满足）：
  - 赋值器插入了一条或多条从黑色对象到白色对象的新引用
  - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

增量更新：CMS采用

原始快照：G1采用





### 4 垃圾收集器

衡量垃圾收集器的三项最重要的指标：

- 内存占用（Footprint）
- 吞吐量（Throughput）
- 延迟（Latency）



#### 垃圾收集器介绍

1. **Serial收集器**
   - 单线程工作（进行垃圾收集时必须暂停其他所有工作线程）
   - 基于标记-复制算法的新生代收集器
   - 简单而高效
   - 多用在客户端
2. **ParNew收集器**
   - 实质上是Serial收集器的多线程并行版本
   - 通常与CMS收集器配合工作
   - 多用在服务端
3. **Parallel Scavenge收集器**
   - 并行多线程
   - 基于标记-复制算法的新生代收集器
   - 吞吐量优先收集器
   - 垃圾收集的自适应调节策略
4. **Serial Old收集器**
   - 实质上是Serial收集器的老年代版本
   - 基于标记-整理算法的实现
5. **Parallel Old收集器**
   - 实质上是Parallel Scavenge收集器的老年版本
   - 基于标记-整理算法实现
6. **CMS收集器**
   - 基于标记-清除算法实现
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 重新标记
     4. 并发清除
   - 缺点：
     - 对处理器资源非常敏感（并发）
     - 无法处理浮动垃圾（并发清除阶段产生的新垃圾）
     - 收集结束时会产生大量空间碎片（标记-清除算法的缺陷）
7. **Garbage First收集器**
   - JDK6实验--->JDK8完全功能
   - 设计思路：面向局部收集
   - 内存布局形式：基于Region
     - 把Java堆划分为多个<u>大小相等</u>的独立区域
     - 不同的Region可以扮演不同角色
     - 收集器对不同的角色的Region采用不同的策略
     - Humongous区域用来存储大对象
     - Region是单次回收的最小单元
     - 可预测的<u>停顿时间模型</u>--->维护一个<u>优先级列表</u>（不同Region的回收价值大小）
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 最终标记
     4. 筛选回收
8. **Shenandoah收集器**
   - OpenJDK12新特性
   - 摒弃了记忆集，采用<u>连接矩阵</u>的全局数据结构来记录跨Region的引用关系
   - 工作过程：
     1. 初始标记
     2. **并发标记**
     3. 最终标记
     4. 并发清理
     5. **并发回收**
     6. 初始引用更新
     7. **并发引用更新**
     8. 最终引用更新
     9. 并发清理
   - 通过读屏障和转发指针*Brooks Pointers*来解决并发回收阶段的困难
9. **ZGC收集器**
   - JDK11新特性（仅支持Linux）
   - 低延迟，并发，标记-整理算法
   - 基于Region内存布局
   - 读屏障
   - 染色指针
   - 内存多重映射
   - 工作过程：
     1. 并发标记
     2. 并发预备重分配
     3. 并发重分配
     4. 并发重映射
10. **Epsilon收集器**
    - JDK11新特性
    - 运行负载小，**没有任何回收行为**（适合微服务化、无服务化等流行趋势）



> 对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1

*CMS和G1都是低延迟垃圾收集器*





### 5 内存分配与回收策略

#### 垃圾收集器日志

JDK9统一了日志处理框架

HotSpot垃圾收集器日志级别：

1. Trace
2. Debug
3. Info
4. Warning
5. Error
6. Off



#### HotSpot内存分配与回收规则

- 当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
- 大于设定值的对象直接在老年代分配
- 对象头中的年龄计数器在每一次Minor GC之后会将年龄+1，当超过一定程度（默认15）后，对象从Survivor区晋升到老年代中
- 如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
- 老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC









# 第二部分 虚拟机执行子系统

## 第3章 类文件结构

### 1 Class类文件的结构

> Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与"Class文件"这种特定的二进制文件格式所关联

Class文件中包含<u>Java虚拟机指令集</u>、<u>符号表</u>以及若干<u>其他辅助信息</u>

**任何一个Class文件**都对应着**唯一一个类或接口**的定义信息，但是反过来类或接口不一定都得定义在文件里*（可以动态生成）*

Class文件是一组以**字节**为基础单位的二进制流，各个数据项目严格按照顺序**紧凑**地排列在文件之中*（中间无分隔符等空隙）*

Class文件按**大端字节序**存储

Class文件的数据类型：

- **无符号数**：u1、u2、u4、u8代表1个字节、2个字节、4个字节、8个字节的无符号数
- **表**：表=多个无符号数（+其他表），以“_info”结尾



**Class文件结构**：

- **前4个字节**：魔数，即0xCAFEBABE
- **第5~6字节**：次版本号（JDK1.2~12全部固定为零）
- **第7~8字节**：主版本号（从45开始，大版本+1，如JDK 8为52.0）
- **第9~10字节**：常量池容量计数值，索引从1开始
- **常量池**：u1类型标志位tag+内容（**17种常量**类型数据结构各不相同）
- **2个字节**：访问标志，确认是类还是接口，是否有`public`，`abstract`，`final`等修饰符
- **2个字节**：类索引
- **2个字节**：父索引
- **2个字节**：接口计数器，表示接口索引表的容量
- **一组u2类型数据**：接口索引集合
- **字段表集合**：访问标志、名称索引、描述符索引、属性数量、属性表集合
- **方法表集合**：与字段表格式基本一致，方法的Java代码放在属性表的"Code"属性里



**类索引查找全限定名的过程：**

类索引--->常量池{类描述符常量（如CONSTANT_Class_info）--->全限定名字符串（如CONSTANT_Utf8_info）}

![](Java虚拟机.assets/3.png)



**方法重载**：要求名称相同，特征签名不同

特征签名：

- 字节码层面：方法的返回值、受查异常表
- Java代码层面：方法名称、参数顺序、参数类型





### 2 字节码指令

Java虚拟机指令长度为**一个字节**

Java虚拟机指令=**操作码**(Opcode)+**操作数**(Operand)

大多数指令都不包含操作数，后者都存放在**操作数栈**中



编译器会在编译期或运行期会：

- 将byte、short类型带符号扩展为int类型
- 将boolean、char类型零位扩展为int类型



JVM严格遵循IEEE 754标准



- 宽化类型转换：无须显式的转换指令（如int类型到long类型），安全转换
- 窄化类型转化：需要显式的转换指令（如int类型到short类型），可能有上限溢出、下限溢出、精度丢失和正负号转换的情况
  - float/double ---> int/long：
    - NaN ---> 0
    - 转换类型范围能够表示 ---> IEEE 754向零舍入模式取整
    - 无穷大或转换类型范围不够表示 ---> 转换类型的最大数或最小数
  - double ---> float：
    - 转换类型范围能够表示 ---> IEEE 754向零舍入模式取整
    - 转换结果绝对值太小 ---> 正负零
    - 转换结果绝对值太大 --->正负无穷大



#### 公有设计，私有实现

公有设计，私有实现指JVM规范统一，私有虚拟机实现在满足规范的前提下可以进行优化

《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：**Class文件格式** + **字节码指令集**

虚拟机的2种实现方式：

1. 将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集
2. 将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集



Class文件格式具有平台中立、紧凑、稳定、可扩展的特点是Java技术体系实现平台无关、语言无关两项特性的重要支柱







## 第4章 虚拟机类加载机制

### 1 类加载的时机

Java代码的执行过程：

1. **编译**：编译器编译Java代码 ---> 生成Class文件
2. **类加载**：JVM将描述类的数据从Class文件加载到内存，并进行校验、转换解析和初始化
3. **运行**：动态加载 + 动态连接



一个类型（类或接口）的生命周期：

1. **加载**Loading
2. **连接**Linking - **验证**Verification
3. **连接**Linking - **准备**Preparation
4. **连接**Linking - **解析**Resolution*（某些情况下可以在初始化之后再开始）*
5. **初始化**Initialization
6. **使用**Using
7. **卸载**Unloading



图



对一个类型进行**主动引用**（必须立即初始化）的时机：

1. 遇到new关键字、读取静态字段或静态方法
2. 反射调用
3. 父类先初始化
4. 先初始化main主类
5. 解析结果为REF_getStatic、REF_puStatic、REF_invokeStatic、REF_newInvokeSpecial*（JDK 8）*
6. 遇到default关键字，接口需要在实现类之前初始化*（JDK 8）*



不会触发初始化的引用类型方式称为**被动引用**

被动引用举例：

1. 通过子类引用父类的静态字段，不会导致子类初始化
2. 通过数组定义来引用类，不会触发此类的初始化
   - 虚拟机自动生成一个继承Object的子类，封装数组应用的属性和方法（包括用户可以使用的length()和clone()）
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类初始化





### 2 类加载过程

#### 加载

加载阶段，JVM的动作：

1. 通过一个类的**全限定名**来获取定义此类的**二进制字节流**
2. 将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**
3. 在内存中生成一个代表这个类的**Class对象**，作为方法区这个类的各种数据访问入口



**非数组类型**由内置的引导类加载器或自定义的类加载器完成加载

**数组类型**遵循以下规则：

- 组件类型为引用类型：递归加载
- 组件类型为基本类型：引导类加载器
- 可访问性与其组件类型可访问性一致

*组件类型：数组去掉一个维度的类型*



#### 验证

验证阶段的目的：确保Class文件的字节流中包含的信息**符合**《Java虚拟机规范》的**全部约束要求**，保证运行后不会危害虚拟机自身的安全

验证阶段，JVM的动作：

1. 文件格式验证：是否符合Class文件结构的规范
2. 元数据验证：语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息
3. 字节码验证：JDK 7以后，只需要检查方法表-属性表-Code属性-StackMapTable（由Javac编译器处理完成）中的属性是否合法
4. 符号引用验证：发生在符号引用转化为直接引用时



#### 准备

准备阶段，JVM将**静态变量放入内存**：

- JDK 7之前，放入方法区
- JDK 7之后，放入Java堆

非final：此时只是开辟了内存空间，但由于Java方法还未执行，故并未赋值

final：准备阶段生成ConstaneValue属性，直接赋值



#### 解析

解析阶段：JVM将常量池内的**符号引用**替换为**直接引用**

符号引用（Synmbolic References）：以一组符号来描述所引用的目标

直接引用（Direct References）：直接指向目标的指针、相对偏移量或间接定位到目标的句柄



类或接口的解析步骤：

1. 不是数组：传递全限定名
2. 是数组
3. 符号引用验证

字段的解析步骤：

1. 类或接口本身有匹配的字段，直接返回
2. 否则，接口从下往上递归搜索
3. 否则，继承关系从下往上递归搜索
4. 否则，抛出java.lang.NoSuchFieldError异常
5. 返回引用后进行权限验证，不具备对字段的访问权限则抛出java.lang.IllegalAccessError异常

类方法的解析步骤：

1. 若是接口，直接抛出java.lang.IncompatibleClassChangeError
2. 类本身有匹配的方法，直接返回
3. 否则，继承关系从下往上递归搜索
4. 否则，接口从下往上递归搜索
5. 否则，抛出java.lang.NoSuchMethodError异常
6. 返回引用后进行权限验证，不具备对字段的访问权限则抛出java.lang.IllegalAccessError异常

接口方法的解析步骤：

1. 若是类，直接抛出java.lang.IncompatibleClassChangeError
2. 接口本身有匹配的方法，直接返回
3. 否则，接口从下往上递归搜索
4. 否则，继承关系从下往上递归搜索
5. 否则，抛出java.lang.NoSuchMethodError异常
6. JDK 9之后，返回引用后进行权限验证，不具备对字段的访问权限则抛出java.lang.IllegalAccessError异常



#### 初始化

初始化阶段，JVM**开始执行**类中的**Java代码**

初始化阶段就是执行类构造器\<clinit\>()方法的过程

关于\<clinit\>()方法：

- 由Java编译器收集**所有类变量的赋值动作** + **静态语句块**自动生成
- JVM保证子类的\<clinit\>()方法执行前，所有父类的\<clinit\>()方法已经执行完毕
- 由于以上一条，父类中的静态语句块优先于子类的变量赋值操作执行
- 如果类或接口中没有变量的赋值操作也没有静态语句块，编译器可以不生成\<clinit\>()方法
- 执行接口的\<clinit\>()方法不需要先执行父接口的\<clinit\>()方法
- JVM必须保证一个类的\<clinit\>()方法多线程环境中被正确地加锁同步，同一时间只会有一个线程去执行这个类的\<clinit\>()方法



### 3 类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性



#### 双亲委派模型

类加载器分为：

- 启动类加载器（Bootstrap ClassLoader）：虚拟机内置，HotSpot中使用C++实现
- 其他所有的类加载器：虚拟器外部，继承自java.lang.ClassLoader



**三层类加载器架构**：

1. 启动类加载器（Bootstrap Class Loader）：加载\<JAVA_HOME\>\lib\目录下的类库
2. 扩展类加载器（Extension Class Loader）：加载\<JAVA_HOME\>\lib\ext\目录下的类库
3. 应用程序类加载器（Application Class Loader）：加载用户类路径上所有的类库，默认类加载器



**双亲委派模型**：自定义类加载器 ---> 应用程序类加载器 ---> 扩展类加载器 ---> 启动类加载器



图



双亲委派模型的工作过程：

1. 类加载器收到类加载请求
2. 将请求委派给父类加载器，一层层委派直到最顶层的启动类加载器
3. 若父类加载器没有找到所需的类，则再由子加载器加载



查看java.lang.ClassLoader.loadClass的源码：

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 如果父类加载器抛出ClassNotFoundException
                    // 说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    // 在父类加载器无法加载时
                    // 再调用本身的findClass方法来进行类加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```



双亲委派模型被破坏的情况：

1. JDK1.2之前已有类加载器但还未引入双亲委派模型
2. 上层的基础加载器需要调取用户代码
3. 代码热替换和模块热部署





### 4 Java模块化系统

Java模块化系统于JDK 9引入

启用模块化进行封装 ---> 模块声明对其他模块的显示依赖 --->JVM**启动时**即验证依赖关系是否完备*（避免了缺少依赖的运行时异常）*

模块化信息：module-info.class文件



模块分类：

- 匿名模块：所有类路径下的JAR文件等
- 具名模块：只能访问其以来路径中的模块和包
- 自动模块：不包含模块定义的JAR文件放置到模块路径后自动生成，默认依赖所有模块



JDK 9以后的类加载器委派关系：

图







## 第8章 虚拟机字节码执行引擎
