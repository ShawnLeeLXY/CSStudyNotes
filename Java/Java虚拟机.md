# 第一部分 走近Java

## 第1章 走进Java









# 第二部分 自动内存管理

## 第2章 Java内存区域与内存溢出异常

### 1 运行时数据区域

**程序计数器：**

- 当前线程执行的字节码的行号指示器
- 线程私有

**Java虚拟机栈：**

- 线程私有
- 每个方法被执行时都会创建一个栈帧
- 虚拟机栈-局部变量表-局部变量槽（Slot）
  - 1个变量槽32bit或64bit，甚至更多
  - long、double类型占用2个变量槽，其他数据类型占用1个
- HotSpot不支持动态扩展栈容量
- HotSpot将本地方法栈和虚拟机栈合二为一
- 栈深度溢出：StackOverFlowError
- 栈扩展失败（或申请栈空间失败）：OutOfMemoryError

**Java堆：**

- 唯一目的：存放对象实例
- 物理空间可不连续，逻辑上连续
- 可选固定大小或者可扩展
- 无法再实例分配或扩展：OutOfMemoryError

**方法区：**

- 永久代*（JVM用管理堆的办法管理方法区）*--->元空间*（JDK8及以后）*
- 不需要连续的内存
- 可选固定大小或者可扩展
- 可选不实现垃圾收集
- 运行时常量池：
  - 加载Class文件中的常量池表（包含各种字面量与符号引用）
  - 动态性：运行期间也可以将新的常量放入池中
- 无法满足新的内存分配需求：OutOfMemoryError

**直接内存：**

- 不是虚拟机运行时数据区的一部分
- JDK1.4中引入，在一些场景中显著提高性能





### 2 HotSpot虚拟机对象

**虚拟机创建对象的步骤：**

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用
2. 为新生对象分配内存，分配方式：
   - 指针碰撞（Bump The Pointer）
   - 空闲列表（Free List）
3. 将分配到的内存空间初始化为零值
4. 对对象进行必要的设置

对象在堆内存中的**存储布局**可以分为3个部分：

1. 对象头
   - 存储自身运行时数据（如HashCode、对象年龄计数器等）
   - 存储类型指针
2. 实例数据
   - 默认分配顺序
   - 相同宽度字段分配到一起
   - 满足上一个条件的情况下，父类中定义的变量出现在子类之前
3. 对齐填充
   - 对象起始地址必须为8字节的整数倍

**对象的访问方式：**

- 使用**句柄**访问（句柄池，实例池）

![](Java虚拟机.assets/1.png)

- 使用**直接指针**访问

![](Java虚拟机.assets/2.png)







## 第3章 垃圾收集器与内存分配策略

### 1 垃圾收集

垃圾收集（Garbage Collection，GC）

- **程序计数器**、**虚拟机栈**、**本地方法栈**的内存在<u>方法或线程结束时</u>就跟着回收了
- **Java堆**和**方法区**的内存的分配和回收是<u>动态</u>的

**对象回收判断方法：**

1. **引用计数算法**
   - 对象被引用一次，计数器值+1
   - 引用失效，计数器值-1
   - 计数器值=0将被GC回收
2. **可达性分析算法**（Java采用）
   - GC Roots：起始节点集
   - GC Roots到某个对象不可达，则此对象可回收
   - 回收对象的两次标记过程：
     1. 是否有与GC Roots相连接的<u>引用链</u>
     2. 对象是否覆盖`finalize()`方法或`finalize()`方法已被调用过

引用类型强度：**强引用**>**软引用**>**弱引用**>**虚引用**

**回收方法区：**

- 判定回收常量的条件：当前系统没有任何一个字符串对象的值是该常量
- 判定回收类型的条件：
  - 该类所有的<u>实例</u>都已经被回收
  - 加载该类的<u>类加载器</u>已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用*（反射）*





### 2 垃圾收集算法

**分代收集理论**：

- 建立在以下假说之上：
  1. 弱分代假说：绝大多数对象都是朝生夕灭的
  2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
  3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数
- 在主流Java虚拟机里体现为Java堆被划分成：
  1. **新生代（Young Generation）：**大量将要被回收的对象
  2. **老年代（Old Generation）：**由未被回收的新生代对象逐步晋升，转而放入老年代存放

---

- Partial GC:
  - Minor GC: 收集新生代
  - Major GC: 收集老年代（CMS）
  - Mixed GC: 整个新生代+部分老年代（G1）
- Full GC: 整个Java堆+方法区

---

**标记-清除算法：**最基础的收集算法

**标记-复制算法：**半区复制算法--->Appel式回收算法

Appel式回收：

- 新生代内存分为Eden(80%)+2*Survivor(10%)
- 分配担保（Handle Promotion）：Survivor空间不足就需要其他内存区域

**标记-整理算法：**让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存

在HotSpot中，Parallel Old收集器是基于标记-整理算法的，CMS收集器是基于标记-清除算法的





### 3 HotSpot的算法细节实现

所有收集器在**根节点枚举**这一步骤时都是必须暂停用户线程的*（所谓Stop The World）*

HotSpot使用**OopMap**的数据结构直接准确得到哪些地方存放着对象引用
--->为避免每条指令都生成OopMap，设置一定数量的**安全点（Safepoint）**，代码指令流到达安全点后才能够暂停程序并开始垃圾收集
--->抢先式中断*（全中断并检查是否在安全点上）*和主动式中断*（轮询标志位）*

**安全区域：**引用关系不发生变化的代码片段

**记忆集：**一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构

**卡表：**实现记忆集的一种方式，定义了记忆集的记录精度、与堆内存的映射关系等

HotSpot通过**写屏障**技术维护卡表状态

- 三色标记：黑色（存活）、灰色（正在扫描）、白色（不可达）
- 并发出现”对象消失“问题的条件（同时满足）：
  - 赋值器插入了一条或多条从黑色对象到白色对象的新引用
  - 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

增量更新：CMS采用

原始快照：G1采用





### 4 垃圾收集器

衡量垃圾收集器的三项最重要的指标：

- 内存占用（Footprint）
- 吞吐量（Throughput）
- 延迟（Latency）



#### 垃圾收集器介绍

1. **Serial收集器**
   - 单线程工作（进行垃圾收集时必须暂停其他所有工作线程）
   - 基于标记-复制算法的新生代收集器
   - 简单而高效
   - 多用在客户端
2. **ParNew收集器**
   - 实质上是Serial收集器的多线程并行版本
   - 通常与CMS收集器配合工作
   - 多用在服务端
3. **Parallel Scavenge收集器**
   - 并行多线程
   - 基于标记-复制算法的新生代收集器
   - 吞吐量优先收集器
   - 垃圾收集的自适应调节策略
4. **Serial Old收集器**
   - 实质上是Serial收集器的老年代版本
   - 基于标记-整理算法的实现
5. **Parallel Old收集器**
   - 实质上是Parallel Scavenge收集器的老年版本
   - 基于标记-整理算法实现
6. **CMS收集器**
   - 基于标记-清除算法实现
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 重新标记
     4. 并发清除
   - 缺点：
     - 对处理器资源非常敏感（并发）
     - 无法处理浮动垃圾（并发清除阶段产生的新垃圾）
     - 收集结束时会产生大量空间碎片（标记-清除算法的缺陷）
7. **Garbage First收集器**
   - JDK6实验--->JDK8完全功能
   - 设计思路：面向局部收集
   - 内存布局形式：基于Region
     - 把Java堆划分为多个<u>大小相等</u>的独立区域
     - 不同的Region可以扮演不同角色
     - 收集器对不同的角色的Region采用不同的策略
     - Humongous区域用来存储大对象
     - Region是单次回收的最小单元
     - 可预测的<u>停顿时间模型</u>--->维护一个<u>优先级列表</u>（不同Region的回收价值大小）
   - 收集步骤：
     1. 初始标记
     2. 并发标记
     3. 最终标记
     4. 筛选回收
8. **Shenandoah收集器**
   - OpenJDK12新特性
   - 摒弃了记忆集，采用<u>连接矩阵</u>的全局数据结构来记录跨Region的引用关系
   - 工作过程：
     1. 初始标记
     2. **并发标记**
     3. 最终标记
     4. 并发清理
     5. **并发回收**
     6. 初始引用更新
     7. **并发引用更新**
     8. 最终引用更新
     9. 并发清理
   - 通过读屏障和转发指针*Brooks Pointers*来解决并发回收阶段的困难
9. **ZGC收集器**
   - JDK11新特性（仅支持Linux）
   - 低延迟，并发，标记-整理算法
   - 基于Region内存布局
   - 读屏障
   - 染色指针
   - 内存多重映射
   - 工作过程：
     1. 并发标记
     2. 并发预备重分配
     3. 并发重分配
     4. 并发重映射
10. **Epsilon收集器**
    - JDK11新特性
    - 运行负载小，**没有任何回收行为**（适合微服务化、无服务化等流行趋势）



> 对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1

*CMS和G1都是低延迟垃圾收集器*





### 5 内存分配与回收策略

#### 垃圾收集器日志

JDK9统一了日志处理框架

HotSpot垃圾收集器日志级别：

1. Trace
2. Debug
3. Info
4. Warning
5. Error
6. Off



#### HotSpot内存分配与回收规则

- 当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
- 大于设定值的对象直接在老年代分配
- 对象头中的年龄计数器在每一次Minor GC之后会将年龄+1，当超过一定程度（默认15）后，对象从Survivor区晋升到老年代中
- 如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
- 老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC









# 第三部分 虚拟机执行子系统

## 第6章 类文件结构

### 1 Class类文件的结构

> Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与"Class文件"这种特定的二进制文件格式所关联

Class文件中包含<u>Java虚拟机指令集</u>、<u>符号表</u>以及若干<u>其他辅助信息</u>

**任何一个Class文件**都对应着**唯一一个类或接口**的定义信息，但是反过来类或接口不一定都得定义在文件里*（可以动态生成）*

Class文件是一组以**字节**为基础单位的二进制流，各个数据项目严格按照顺序**紧凑**地排列在文件之中*（中间无分隔符等空隙）*

Class文件按**大端字节序**存储

Class文件的数据类型：

- **无符号数**：u1、u2、u4、u8代表1个字节、2个字节、4个字节、8个字节的无符号数
- **表**：表=多个无符号数（+其他表），以“_info”结尾



Class文件结构：

- 前4个字节：魔数，即0xCAFEBABE
- 第5~6字节：次版本号（JDK1.2~12全部固定为零）
- 第7~8字节：主版本号（从45开始，大版本+1，如JDK 8为52.0）
- 第9~10字节：常量池容量计数值，索引从1开始
- 常量池：u1类型标志位+内容（**17种常量**类型数据结构各不相同）
- 2个字节：访问标志，确认是类还是接口，是否有`public`，`abstract`，`final`等修饰符
- 2个字节：类索引
- 2个字节：父索引
- 2个字节：接口计数器，表示接口索引表的容量
- 一组u2类型数据：接口索引集合
- 字段表集合：访问标志、名称索引、描述符索引、属性数量、属性表集合
- 方法表集合：与字段表格式基本一致，方法的Java代码放在属性表的"Code"属性里



**类索引查找全限定名的过程：**

类索引--->常量池{类描述符常量（如CONSTANT_Class_info）--->全限定名字符串（如CONSTANT_Utf8_info）}

![](Java虚拟机.assets/3.png)



**方法重载**：要求名称相同，特征签名不同

特征签名：

- 字节码层面：方法的返回值、受查异常表
- Java代码层面：方法名称、参数顺序、参数类型





### 2 字节码指令

Java虚拟机指令长度为**一个字节**

Java虚拟机指令=**操作码**(Opcode)+**操作数**(Operand)

大多数指令都不包含操作数，后者都存放在**操作数栈**中



编译器会在编译期或运行期会：

- 将byte、short类型带符号扩展为int类型
- 将boolean、char类型零位扩展为int类型



JVM严格遵循IEEE754标准
