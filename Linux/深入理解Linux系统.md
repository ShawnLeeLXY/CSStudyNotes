# 深入理解Linux系统

## Linux中的进程

父进程 ---> fork() ---> 子进程

父进程返回子进程的PID，子进程返回0



Linux不区分进程、线程，统一用数据结构**task_struct**来表示所有的执行上下文



为了进行调度，Linux系统将线程区分为三类：

1. 实时先入先出 --- 最高优先级

2. 实时轮转

   前两种优先级从0~99

3. 分时

   优先级从100~139

Linux调度器：

1. **O(1)调度器**：
   - 历史上流行（2.6内核版本）
   - 能够在常数事件执行任务调度
   - **调度队列**被组织成两个数组：**活动数组**和**过期数组**，每个数组都包含140个链表头，指向给定优先级的**双向进程链表**
   - 当活动数组中没有其他任务了，调度器交换两个数组的指针，使得两个数组身份互换
2. **CFS**（Completely Fair Scheduler）：
   - 首次在2.6.23集成到内核中，目前仍是处理<u>非实时任务</u>的默认调度器
   - 主要思想是使用一棵**红黑树**作为调度队列的数据结构
   - 进程节点按照虚拟运行时间（vruntime）排列
   - 在多处理器平台上，每一个运行队列数据结构与一个处理器相对应



多线程对变量的访问可以分为以下几类：

- **多读**：不需要互斥
- **一写一读**或**一写多读**：不进行互斥的话，可能出现**不可重复读**（即线程多次读同一变量，前后的值不一样）的问题，但可以进行“无锁”设计
- **多写一读**或**多写多读**：需要互斥

双buffer"无锁设计" --- **读写分离**：

1. 使用两个buffer，一个提供给读端，一个提供给写端
2. 满足一定条件后两个buffer指针互换3
3. 指针互换时使用自旋锁避免竞争，同时采用共享指针的引用计数来避免指针访问丢失

参见：[百度百科-单写多读](https://baike.baidu.com/item/%E5%8D%95%E5%86%99%E5%A4%9A%E8%AF%BB/22692499?fr=aladdin)



**Linux的启动顺序**：

BIOS加电自检 ---> 读取MBR ---> GRUB完成boot程序 ---> 分配内核数据结构 ---> 启动进程0 ---> 启动init进程和页面守护进程 ---> getty ---> login ---> shell





## Linux中的内存管理

进程的虚拟地址空间 = **代码段** + **数据段** + **堆栈段**

为了节省内存Linux存在共享正文、共享映射文件和写时复制技术



Linux区分以下内存区域：

- ZONE_DMA
- ZONE_NORMAL
- ZONE_HIGHMEM



Linux内存 = 内核 + 内存映射 + 大量页框（用于用户页面、分页缓存等）

其中内核和内存映射的页面在内存中**从来不换出**

**节点描述符**维护**页描述符**数组mem_map和**区域描述符**等信息



Linux 2.6.11之后采用**四级分页策略**

虚拟地址 = 全局目录 + 上级目录 + 中间目录 + 页面 + 偏移



Linux中的内存分配器：

1. **页面分配器**
   - 伙伴算法
   - 容易产生大量内存碎片
2. **slab分配器**
   - 使用了**对象缓存**，由指向一个或多个**slab**的指针组成
   - kmalloc内核服务
3. **vmalloc内存分配器**
   - 用于需要连续虚拟地址空间的请求



**内核中内存**的每个区是用**vm_area_struct**来描述的

每个进程有一个vm_area_struct链表，按照<u>虚拟地址排序</u>以便找到所有的页面



如果任何内存区域的可用空间低于一个阈值，对应内存结点的页面守护进程kswap初始化**PFRA**（页框回收算法）

> PFRA用一个类似时钟的算法来选择旧页面换出。这个算法的核心是一个循环，它扫描每个区域的活动和非活动列表，试图按照不同的紧迫程度回收不同类型的页面

PFRA为每个页面维护两个标记：

- `PG_active`：是否活动
- `PG_referenced`：是否被引用

后台守护线程pdflush：

1. 周期性醒来回收非常旧的脏页面
2. 可用内存下降到一个阈值时醒来回收脏页面





## Linux中的I/O系统

每个I/O设备都在/dev目录下被分配了一条路径

设备文件分为两类：

- **块特殊文件**：由一组具有编号的块组成，每一个块都能够被独立地寻址和访问
- **字符特殊文件**：用于表示输入和输出的字符流的设备

每个驱动程序都通过一个**主设备号**标识，若一个驱动程序支持多个设备，则每个设备使用一个**次设备号**标识



Linux依靠一个I/O调度器来保证磁头反复移动以减少延迟



**可加载模块**（loadable module）是系统运行时可以加载到内核的代码块，如添加一个新的I/O设备

加载步骤：

1. 模块被动态地重新部署
2. 系统检查这个驱动程序需要的资源是否够用
3. 设置所有需要的中断向量
4. 更新驱动转换表使其能够处理新的主设备类型
5. 运行驱动程序来完成可能需要的特定设备的初始化工作



磁盘I/O方式：

- **缓存I/O**：又被称作标准I/O，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。
- **直接I/O**：应用程序直接访问磁盘数据，而不经过内核缓冲区



Linux的五种网络IO模型：

1. **同步阻塞I/O**
2. **同步非阻塞I/O**
3. **多路复用I/O**（异步阻塞）
4. **信号驱动I/O**
5. **异步I/O**（异步非阻塞）

![](深入理解Linux系统.assets/io.png)

详细I/O模型讲解参考：[聊聊Linux 五种IO模型](https://www.jianshu.com/p/486b0965c296)





## Linux文件系统

绝对路径

工作目录

相对路径



如果计算机有多个磁盘，Linux允许将其余磁盘挂载到一个擦盘的目录树上



POSIX允许一个进程使用一个不可分割的操作对小到一个字节、大到整个文件加锁



Linux系统提供了两种锁：

- **共享锁**：如果文件的一部分已经被加了共享锁，那么在上面尝试加共享锁是允许的，但是加互斥锁是不会成功的
- **互斥锁**：如果文件的一部分已经被加了互斥锁，那么在互斥锁解除之前加任何锁都不会成功



**虚拟文件系统**（Virtual File System, VFS）支持的文件系统抽象：

- superblock：特定的文件系统
- dentry：目录项
- inode：i节点被存放在i节点表中
- file：打开的文件



Linux的文件系统实现：

- ex2：块组 = 超级块 + 组描述符 + 块位图 + i节点位图 + i节点 + 数据块
- ex3：日志文件系统
- ex4：改进的日志文件系统，使用了**盘区**
- /proc：为系统中的每个进程在/proc中创建一个目录



文件系统内部主要使用三种表：

1. 文件描述符表
2. 打开文件描述符表
3. i节点表





## Linux的安全性

当一个进程的SETUID位打开，它的有效UID将变成可执行文件的所有者的UID

当一个进程试图打开一个文件时，系统检查的将是它的有效UID，而不是真正的UID

