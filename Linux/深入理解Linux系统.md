# 深入理解Linux系统

## Linux中的进程

父进程 ---> fork() ---> 子进程

父进程返回子进程的PID，子进程返回0



Linux不区分进程、线程，统一用数据结构**task_struct**来表示所有的执行上下文



为了进行调度，Linux系统将线程区分为三类：

1. 实时先入先出 --- 最高优先级

2. 实时轮转

   前两种优先级从0~99

3. 分时

   优先级从100~139

Linux调度器：

1. **O(1)调度器**：
   - 历史上流行（2.6内核版本）
   - 能够在常数事件执行任务调度
   - **调度队列**被组织成两个数组：**活动数组**和**过期数组**，每个数组都包含140个链表头，指向给定优先级的**双向进程链表**
   - 当活动数组中没有其他任务了，调度器交换两个数组的指针，使得两个数组身份互换
2. **CFS**（Completely Fair Scheduler）：
   - 首次在2.6.23集成到内核中，目前仍是处理<u>非实时任务</u>的默认调度器
   - 主要思想是使用一棵**红黑树**作为调度队列的数据结构
   - 进程节点按照虚拟运行时间（vruntime）排列
   - 在多处理器平台上，每一个运行队列数据结构与一个处理器相对应



**Linux的启动顺序**：

BIOS加电自检 ---> 读取MBR ---> GRUB完成boot程序 ---> 分配内核数据结构 ---> 启动进程0 ---> 启动init进程和页面守护进程 ---> getty ---> login ---> shell





## Linux中的内存管理

进程的虚拟地址空间 = **代码段** + **数据段** + **堆栈段**

为了节省内存Linux存在共享正文、共享映射文件和写时复制技术



Linux区分以下内存区域：

- ZONE_DMA
- ZONE_NORMAL
- ZONE_HIGHMEM



Linux内存 = 内核 + 内存映射 + 大量页框（用于用户页面、分页缓存等）

其中内核和内存映射的页面在内存中**从来不换出**

**节点描述符**维护**页描述符**数组mem_map和**区域描述符**等信息



Linux 2.6.11之后采用**四级分页策略**

虚拟地址 = 全局目录 + 上级目录 + 中间目录 + 页面 + 偏移

